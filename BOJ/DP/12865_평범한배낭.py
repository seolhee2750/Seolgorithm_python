"""
"dp - 냅색 알고리즘 (0-1 배낭 문제)"
: 담을 수 있는 물건이 나누어 질 수 없을 때! 가치와 무게를 고려하여 배낭에 물건을 담는 문제.

(# 처음 접한 알고리즘이고,, 어렵게 느껴져서 블로그 정리 전 1차적으로 풀이 정리하며 코드 회고,,!!)

[풀이]
[1] memory 리스트를 생성하는데, 행은 순서대로 입력되는 각 물건들을 의미, 열은 1부터 k까지의 무게를 의미한다.
1-1. 여기서 무게가 1일 때부터 k가 될 때까지 차례대로 보는 이유는,
담을 수 있는 최대 무게에 따른 최대 가치를 순서대로 연산하며 결국 [n][k]에서는 누적된 최대 가치를 알 수 있도록 하기 위함이다.
1-2. 따라서 memory 리스트의 각 '열'은 배당에 담을 수 있는 최대 무게를 의미한다고 생각하면 된다.

[2] 위의 memory 리스트의 [1, 1]부터 [n, k]까지 순서대로 돌며 값을 갱신해준다.
2-1. 돌고 있는 해당 요소의 무게(열)가 현재 행에 해당하는 물건의 무게보다 작을 경우, 새로운 무게를 넣어줄 자리가 없으므로
새로운 연산 없이 이전 행에서의 해당 무게 최대 가치를 그대로 넣어준다.
2-2. 돌고 있는 해당 요소의 무게(열)이 현재 행에 해당하는 물건의 무게보다 클 경우, 새로운 무게를 더할 수 넣어줄 수 있으므로
이 물건을 넣을지, 넣지 말지 정해야 한다.
2-3. 물건을 넣는게 이득인지, 넣지 않는게 이득인지는 당연히 가치가 더 높은 쪽을 선택하면 된다.
따라서 memory[i-1][j] (이전 행의 현재 무게에 해당하는 열에 담긴 최대 가치), 그리고
memory[i-1][j-w]+v (이전 행의, 현재 무게인 j에서 현재 물건의 무게 w를 뺀 자리에 담긴 최대 가치에 현재 물건의 가치를 더한 값) 중에서
더 큰 값을 골라서 memory[i][j]에 저장해주면 된다.

3. 위의 과정을 통해 memory 리스트에 누적된 마지막 요소 값은 k무게일 때의 최대 가치를 가리키게 된다.
"""

n, k = map(int, input().split())
memory = [[0]*(k+1) for _ in range(n+1)] # [n+1][k+1] 크기의 0으로 채워진 배열

for i in range(1, n+1):
    w, v = map(int, input().split())
    for j in range(1, k+1):
        if w <= j: memory[i][j] = max(memory[i-1][j], memory[i-1][j-w]+v)
        else: memory[i][j] = memory[i-1][j]

print(memory[n][k])

